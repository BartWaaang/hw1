//task2
#include<opencv2/opencv.hpp>
#include<opencv2/highgui/highgui.hpp>
#include<math.h>
#include<stdio.h>
#include<iostream>
using namespace cv;
using namespace std;



int main()
{
	Mat image = imread("E:\\课件\\图像\\第一次作业\\第二次作业\\lena.bmp",IMREAD_GRAYSCALE);
	Mat dst8 = image.clone(), dst7 = image.clone(), dst6 = image.clone(), dst5 = image.clone(), dst4 = image.clone(), dst3 = image.clone(), dst2 = image.clone(), dst1 = image.clone();
	for (int i = 0; i < image.rows; i++)
	{
		for (int j = 0; j < image.cols; j++)
		{
			uchar n = image.at<uchar>(i, j);
			uchar k7 = n / 2, k6 = n / 4, k5 = n / 8, k4 = n / 16, k3 = n / 32, k2 = n / 64, k1 = n / 128;
			dst8.at<uchar>(i, j) = n;
			dst7.at<uchar>(i, j) = k7*2;
			dst6.at<uchar>(i, j) = k6*4;
			dst5.at<uchar>(i, j) = k5*8;
			dst4.at<uchar>(i, j) = k4*16;
			dst3.at<uchar>(i, j) = k3*32;
			dst2.at<uchar>(i, j) = k2*64;
			dst1.at<uchar>(i, j) = k1*128;
		}
	}
	imwrite("E:\\课件\\图像\\第一次作业\\结果\\8.bmp", dst8);
	imwrite("E:\\课件\\图像\\第一次作业\\结果\\7.bmp", dst7);
	imwrite("E:\\课件\\图像\\第一次作业\\结果\\6.bmp", dst6);
	imwrite("E:\\课件\\图像\\第一次作业\\结果\\5.bmp", dst5);
	imwrite("E:\\课件\\图像\\第一次作业\\结果\\4.bmp", dst4);
	imwrite("E:\\课件\\图像\\第一次作业\\结果\\3.bmp", dst3);
	imwrite("E:\\课件\\图像\\第一次作业\\结果\\2.bmp", dst2);
	imwrite("E:\\课件\\图像\\第一次作业\\结果\\1.bmp", dst1);
	waitKey(0);
	return 0;
}

//task3


#include<opencv2/opencv.hpp>
#include<opencv2/highgui/highgui.hpp>
#include<math.h>
#include<stdio.h>
#include<iostream>
using namespace cv;
using namespace std;


int main()
{
	Mat image = imread("E:\\课件\\图像\\第一次作业\\第二次作业\\lena.bmp", IMREAD_GRAYSCALE);
	int sum = 0, sum2 = 0;
	for (int i = 0; i < image.rows; i++)
	{
		for (int j = 0; j < image.cols; j++)
		{
			sum = sum + image.at<uchar>(i, j);
		}
	}
	int avr = sum / (image.rows*image.cols);
	for (int i = 0; i < image.rows; i++)
	{
		for (int j = 0; j < image.cols; j++)
		{
			sum2 = sum2 + (image.at<uchar>(i, j) - avr) ^ 2;
		}
	}
	double p = double(sum2) / double((image.rows*image.cols));
	double stdev = sqrt(p);
	cout << "均值为：" << avr << '\n';
	cout << "方差为：" << p << '\n';
	system("pause");
	return 0;
}

//task4
#include<opencv2/opencv.hpp>
#include<opencv2/highgui/highgui.hpp>
#include<math.h>
#include<stdio.h>
#include<iostream>
using namespace cv;
using namespace std;


void nearst(Mat& src, Mat&dst, int k);
void bilinear(Mat& src, Mat&dst, int k);
void bicubic(Mat& src, Mat&dst, int k);
double functionbi(double x, double a);
int main()
{
	Mat image = imread("E:\\课件\\图像\\第一次作业\\第二次作业\\lena.bmp", IMREAD_GRAYSCALE);
	Mat dst1(2048, 2048, CV_8UC1, Scalar(0, 0, 0));
	Mat dst2 = dst1.clone();
	Mat dst3 = dst1.clone();
	nearst(image, dst1, 4);
	bilinear(image, dst2, 4);
	bicubic(image, dst3, 4);
	imwrite("E:\\课件\\图像\\第一次作业\\结果\\最近邻.bmp", dst1);
	imwrite("E:\\课件\\图像\\第一次作业\\结果\\双线性.bmp", dst2);
	imwrite("E:\\课件\\图像\\第一次作业\\结果\\双三次.bmp", dst3);
	waitKey(0);
	return 0;

}

void nearst(Mat& src, Mat&dst, int k)
{
	for (double i = 0; i < dst.rows; i++)
	{
		for (double j = 0; j < dst.cols; j++)
		{
			int x = round(double(i / k)), y = round(double(j / k));
			if (x>=src.rows) x = src.rows-1;
			if (y>=src.cols) y = src.cols-1;
			dst.at <uchar>(i,j) = src.at<uchar>(x, y);
		}
	}
}

void bilinear(Mat& src, Mat&dst, int k)
{
	for (double i = 0; i < dst.rows; i++)
	{
		for (double j = 0; j < dst.cols; j++)
		{
			int x = floor(double(i / k)), y = floor(double(j / k));
			if (x >= src.rows) x = src.rows - 1;
			if (y >= src.cols) y = src.cols - 1;
			double u = double(i / k) - x;
			double v = double(j / k) - y;
			if (x < (src.rows - 1) && y < (src.cols - 1))
			{
				dst.at<uchar>(i, j) = (1 - u)*(1 - v)*src.at<uchar>(x, y) + (1 - u)*(v)*src.at<uchar>(x, y + 1) + (u)*(1 - v)*src.at<uchar>(x + 1, y) + (u)*(v)*src.at<uchar>(x + 1, y + 1);
			}
			if (x == src.rows - 1 && y != src.cols - 1)
			{
				dst.at<uchar>(i, j) = (1 - u)*(1 - v)*src.at<uchar>(x, y) + (1 - u)*(v)*src.at<uchar>(x, y + 1) + (u)*(1 - v)*src.at<uchar>(x, y) + (u)*(v)*src.at<uchar>(x, y + 1);
			}
			if (x != src.rows - 1 && y == src.cols - 1)
			{
				dst.at<uchar>(i, j) = (1 - u)*(1 - v)*src.at<uchar>(x, y) + (1 - u)*(v)*src.at<uchar>(x, y) + (u)*(1 - v)*src.at<uchar>(x + 1, y) + (u)*(v)*src.at<uchar>(x + 1, y);
			}
			if (x == src.rows - 1 && y == src.cols - 1)
			{
				dst.at<uchar>(i, j) = (1 - u)*(1 - v)*src.at<uchar>(x, y) + (1 - u)*(v)*src.at<uchar>(x, y) + (u)*(1 - v)*src.at<uchar>(x, y) + (u)*(v)*src.at<uchar>(x, y);
			}
		}
	}
}

void bicubic(Mat& src, Mat&dst, int k)
{
	for (double i = 0; i < dst.rows; i++)
	{
		for (double j = 0; j < dst.cols; j++)
		{
			uchar sum=0;
			int x = floor(double(i / k)), y = floor(double(j / k));
			double v = double(i / k) - x, u = double(j / k) - y;
			for (int a = -1; a < 3; a++)
			{
				for (int b = -1; b < 3; b++)
				{
					int p = x + a, q = y + b;
					if (p >= src.rows) p = src.rows - 1;
					if (p < 0) p = 0;
					if (q >= src.rows) q = src.cols - 1;
					if (q < 0) q = 0;
					sum += src.at<uchar>(p, q)*functionbi(a - v, -0.5)*functionbi(b - u, -0.5);

				}
			}
			dst.at<uchar>(i, j) = sum;
			
		}
	}
}

double functionbi(double x,double a)
{
	double s;
	if (abs(x) >= 0 && abs(x) <= 1)
	{
		s = 1 - (3 + a)*x*x + (a + 2)*abs(x)*abs(x)*abs(x);
	}
	if (abs(x) > 1 && abs(x) <= 2)
	{
		s = -4 * a + 8 * a*abs(x) - 5 * a*x*x + a*abs(x)*abs(x)*abs(x);

	}
	return s;
}

//task5
#include<opencv2/opencv.hpp>
#include<opencv2/highgui/highgui.hpp>
#include<math.h>
#include<stdio.h>
#include<iostream>
#include<vector>
using namespace cv;
using namespace std;

void nearst(Mat& src, Mat&dst, int k);
void bilinear(Mat& src, Mat&dst, int k);
void bicubic(Mat& src, Mat&dst, int k);
double functionbi(double x, double a);
void Sheer(Mat& src, Mat&dst, double sh);
void Spin(Mat& src, Mat&dst, double angle);

int main()
{
	Mat image = imread("E:\\课件\\图像\\第一次作业\\第二次作业\\elain.bmp", IMREAD_GRAYSCALE);
	Mat spin(512, 512, CV_8UC1, Scalar(0, 0, 0));
	Mat spin2(2048, 2048, CV_8UC1, Scalar(0, 0, 0));
	Mat spin3 = spin2.clone(), spin4 = spin2.clone();
	Spin(image, spin, 3.14 / 6);
	nearst(spin, spin2, 4);
	bilinear(spin, spin3, 4);
	bicubic(spin, spin4, 4);
	Mat sheer(512, 512, CV_8UC1, Scalar(0, 0, 0));
	Mat sheer2(2048, 2048, CV_8UC1, Scalar(0, 0, 0));
	Mat sheer3 = sheer2.clone(), sheer4 = sheer2.clone();
	Sheer(image, sheer, 1.5);
	nearst(sheer, sheer2, 4);
	bilinear(sheer, sheer3, 4);
	bicubic(sheer, sheer4, 4);
	imwrite("E:\\课件\\图像\\第一次作业\\结果\\最近邻E2.bmp", spin2);
	imwrite("E:\\课件\\图像\\第一次作业\\结果\\双线性E2.bmp", spin3);
	imwrite("E:\\课件\\图像\\第一次作业\\结果\\双三次E2.bmp", spin4);
	imwrite("E:\\课件\\图像\\第一次作业\\结果\\最近邻E.bmp", sheer2);
	imwrite("E:\\课件\\图像\\第一次作业\\结果\\双线性E.bmp", sheer3);
	imwrite("E:\\课件\\图像\\第一次作业\\结果\\双三次E.bmp", sheer4);
	waitKey(0);
	return 0;
}

void Sheer(Mat& src, Mat&dst, double sh)
{
	int x, y, i2, j2;
	for (int i = 0; i < dst.rows; i++)
	{
		for (int j = 0; j < dst.cols; j++)
		{
			//int i2 = i - src.rows / 2, j2 = j - src.cols / 2;
			//x = i2;
			//y = sh*i2 + j2;
			//if (x < dst.rows / 2 && y < dst.cols / 2 && x >= 0 && y >= 0)
			//{
			//	dst.at<uchar>(x, y) = src.at<uchar>(i, j);
			//}
			i2 = i - dst.rows / 2;
			j2 = j - dst.cols / 2;
			x = i2;
			y = j2-sh*i2;
			if (x < src.rows / 2 && y < src.cols / 2 && x >= -src.rows / 2 && y >= -src.cols / 2)
			{
				dst.at<uchar>(i, j) = src.at<uchar>(x + dst.rows / 2, y + dst.cols / 2);
			}
		}
	}
}

void Spin(Mat& src, Mat&dst, double angle)
{
	int x, y, i2, j2;
	for (int i = 0; i < dst.rows; i++)
	{
		for (int j = 0; j < dst.cols; j++)
		{
			i2 = i - dst.rows / 2;
			j2 = j - dst.cols / 2;
			y = j2*cos(angle) - i2*sin(angle);
			x = j2*sin(angle) + i2*cos(angle);
			if (x < src.rows / 2 && y < src.cols / 2 && x >= -src.rows / 2 && y >= -src.cols / 2)
			{
				dst.at<uchar>(i, j) = src.at<uchar>(x + dst.rows / 2, y + dst.cols / 2);
			}
		}
	}
}

void nearst(Mat& src, Mat&dst, int k)
{
	for (double i = 0; i < dst.rows; i++)
	{
		for (double j = 0; j < dst.cols; j++)
		{
			int x = round(double(i / k)), y = round(double(j / k));
			if (x>=src.rows) x = src.rows-1;
			if (y>=src.cols) y = src.cols-1;
			dst.at <uchar>(i,j) = src.at<uchar>(x, y);
		}
	}
}

void bilinear(Mat& src, Mat&dst, int k)
{
	for (double i = 0; i < dst.rows; i++)
	{
		for (double j = 0; j < dst.cols; j++)
		{
			int x = floor(double(i / k)), y = floor(double(j / k));
			if (x >= src.rows) x = src.rows - 1;
			if (y >= src.cols) y = src.cols - 1;
			double u = double(i / k) - x;
			double v = double(j / k) - y;
			if (x < (src.rows - 1) && y < (src.cols - 1))
			{
				dst.at<uchar>(i, j) = (1 - u)*(1 - v)*src.at<uchar>(x, y) + (1 - u)*(v)*src.at<uchar>(x, y + 1) + (u)*(1 - v)*src.at<uchar>(x + 1, y) + (u)*(v)*src.at<uchar>(x + 1, y + 1);
			}
			if (x == src.rows - 1 && y != src.cols - 1)
			{
				dst.at<uchar>(i, j) = (1 - u)*(1 - v)*src.at<uchar>(x, y) + (1 - u)*(v)*src.at<uchar>(x, y + 1) + (u)*(1 - v)*src.at<uchar>(x, y) + (u)*(v)*src.at<uchar>(x, y + 1);
			}
			if (x != src.rows - 1 && y == src.cols - 1)
			{
				dst.at<uchar>(i, j) = (1 - u)*(1 - v)*src.at<uchar>(x, y) + (1 - u)*(v)*src.at<uchar>(x, y) + (u)*(1 - v)*src.at<uchar>(x + 1, y) + (u)*(v)*src.at<uchar>(x + 1, y);
			}
			if (x == src.rows - 1 && y == src.cols - 1)
			{
				dst.at<uchar>(i, j) = (1 - u)*(1 - v)*src.at<uchar>(x, y) + (1 - u)*(v)*src.at<uchar>(x, y) + (u)*(1 - v)*src.at<uchar>(x, y) + (u)*(v)*src.at<uchar>(x, y);
			}
		}
	}
}

void bicubic(Mat& src, Mat&dst, int k)
{
	for (double i = 0; i < dst.rows; i++)
	{
		for (double j = 0; j < dst.cols; j++)
		{
			uchar sum=0;
			int x = floor(double(i / k)), y = floor(double(j / k));
			double v = double(i / k) - x, u = double(j / k) - y;
			for (int a = -1; a < 3; a++)
			{
				for (int b = -1; b < 3; b++)
				{
					int p = x + a, q = y + b;
					if (p >= src.rows) p = src.rows - 1;
					if (p < 0) p = 0;
					if (q >= src.rows) q = src.cols - 1;
					if (q < 0) q = 0;
					sum += src.at<uchar>(p, q)*functionbi(a - v, -0.5)*functionbi(b - u, -0.5);

				}
			}
			dst.at<uchar>(i, j) = sum;
			
		}
	}
}

double functionbi(double x,double a)
{
	double s;
	if (abs(x) >= 0 && abs(x) <= 1)
	{
		s = 1 - (3 + a)*x*x + (a + 2)*abs(x)*abs(x)*abs(x);
	}
	if (abs(x) > 1 && abs(x) <= 2)
	{
		s = -4 * a + 8 * a*abs(x) - 5 * a*x*x + a*abs(x)*abs(x)*abs(x);

	}
	return s;
}
